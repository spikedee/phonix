\input texinfo
@setfilename phonix
@documentencoding UTF-8
@settitle Phonix Phonological Transformation Language

@copying
Copyright @copyright{} 2009 Jesse Bangs.

This manual and Phonix itself are licensed under the BSD license.

@end copying

@titlepage
@title Phonix
@subtitle A Phonological Transformation Language
@author Jesse Bangs
@page
@insertcopying

$LastChangedDate$
@end titlepage

@ifnottex
@node Top
@top Phonix Phonological Transformation Language

@ifnothtml
This file documents a language for modeling phonological change.
@end ifnothtml

@ifnotinfo
This is the manual for Phonix, a language for expressing diachronic and
synchronic phonological processes.
@end ifnotinfo

$LastChangedDate$

@end ifnottex

@contents

@menu
* Quick Start::
* How To Use Phonix::
* The Phonix Language::
* Examples::
* License::
@end menu

@node Quick Start
@chapter Quick Start Guide

You are a busy person. You have sound changes to apply and phonologies to
crunch and you do not have time to read a whole manual. This section is for
you. Writing your first phonology is very easy: all that you need to do is open
up a text file and type the following:

@example
import std.features
import std.symbols
@end example

The first line will automatically add the standard feature set to your
phonology. The second line will add the standard symbol set.  Together, these
provide you with a set of contrastive features and phonetic symbols to allow
you express whatever phonological processes you desire. You can find out more
by reading @ref{std.features} and @ref{std.symbols}.

But you've only started. Your phonology contains rules, and the first and most
important rule in your phonology is I-Nasal. This rule expressed in English is
"every front vowel must be /i/ if the next segment is /n/". (This is, perhaps, not a
very realistic rule, but we're doing this for the sake of simplicity.) In
Phonix, you will write this as such:

@example
rule i-nasal 
[-cons +fr] => i / _n
@end example

A well educated phonologist such as yourself will immediately recognize the
notation being used here. The portion @code{[-cons +fr]} is a @dfn{feature
matrix} that specifies non-consonantal front segments (i.e. front vowels), and
the notation @code{=> i} may be read as "becomes /i/". The portion following
the @code{/} is the @dfn{context}, and the context for this rule is @code{_n},
which we read as "when followed by /n/".

If you didn't understand that, you should read @ref{Rules}, which has a much
fuller explanation. You may also look at the @ref{Romanian} for examples of
other Phonix rules.

Save your phonology in a file called @file{my.phonix}. Let's assume that you
already have the list of underlying forms to which you wish to apply your
transformations saved in @file{lexicon.txt}, with one word on each line.
Conveniently, this is exactly the format that Phonix uses. You can then apply
your rules to your lexicon by typing the following at the command line:

@command{phonix my.phonix -i lexicon.txt}

This will print the output to the screen, one word on each line. Should you
wish to have Phonix save them to a file, simply provide the filename with
@option{-o}:

@command{phonix my.phonix -i lexicon.txt -o output.txt}

@node How To Use Phonix
@chapter How To Use Phonix

@dfn{Phonix} refers to the Phonix programming language for modeling
phonological processes, and informally to the program @file{phonix} that
interprets Phonix language files and applies the rules contained therein to
a lexicon.

In order to use Phonix, you need two things:

@enumerate

@item A @dfn{Phonix file} that contains the feature, symbol, and rule
declarations of the phonology you wish to model. Phonix files conventionally
have the extension @file{.phonix} or @file{.phx}.

@item The lexicon for your phonology--the underlying or ancestral forms before
any rules or sound-changes are applied to them--written with the symbols
defined in your Phonix file. Phonix can read the lexicon from standard input or
from a file.

@end enumerate

The Phonix language is described in detail in @ref{The Phonix Language}. This
section describes how to invoke @file{phonix} to run your phonology files.

A basic invocation of Phonix looks like this:

@example
phonix @var{phonix-file} @var{arguments}
@end example

The only required argument is the @var{phonix-file}, which is a file containing
a phonology definition. The following @var{arguments} are optional.

@table @option

@item -i @var{filename}
@itemx --in @var{filename}
The lexicon file from which underlying/ancestral forms are read to have the
Phonix rules applied to them. If this argument is not given, Phonix reads from
standard input.

@item -o @var{filename}
@itemx --out @var{filename}
The filename to which to write output forms that the rules have applied to. If
this argument is not given, Phonix writes to standard output.

@item -q
@itemx --quiet
When this option is present, Phonix doesn't print any errors except for fatal
error messages.

@item -d
@itemx --debug
When this option is given, Phonix writes a variety of diagnostic messages to
the standard error stream to aid in debugging your phonology.

@item -v
@itemx --verbose
When this option is given, Phonix logs verbosely to the standard error stream.
This creates all of the output generated by @option{-d}, plus more.

@item -w
@itemx --warn-fatal
When this option is given, certain conditions that normally produce a warning
will cause Phonix to immediately exit.

@end table

Phonix requires some version of the Common Language Runtime, commonly known on
Windows as .NET. Through the Mono project, this runtime is widely available on
almost all operating systems. However, the specific way that you invoke
@file{phonix} will depend slightly on your setup.

@enumerate

@item If you are using any version of Windows and @file{phonix.exe} is in the
current directory or any directory in @code{%PATH%}, then you can simply call
@file{phonix} or @file{phonix.exe}. Phonix requires .NET Framework 2.0 or
later, which is standard on all recent versions of Windows.

@item If you are using Linux, you can invoke Phonix with @code{./phonix.exe},
provided that you have the Mono runtime installed. If you are building from
source, there is a @code{make install} target that will install a @file{phonix}
script without the @code{.exe} extension in @code{/usr/local/bin}.

@item If you are using Mac OSX or a POSIX system other than Linux, you can
invoke Phonix with @code{mono phonix.exe}. You must have the Mono runtime
installed, and you need to explicitly call @code{mono} in order to run Phonix.

@end enumerate

@node The Phonix Language
@chapter The Phonix Language

This section covers the syntax and meaning of all aspects of a Phonix file in
detail. The Phonix language is simple but powerful, and it should be very easy
for people who are familiar with basic phonological concepts and rule notation.
If you are not familiar with the basics of generative phonology, you may find
this section tough going.

The Phonix language is @dfn{declarative}: you use Phonix to create a
description of your phonology, and @code{phonix} reads your description and
applies the rules contained therein to the lexicon. There are three basic
elements in a Phonix file: @dfn{features}, @dfn{symbols}, and @dfn{rules}. Each
of these is built up from the previous parts: features are the most basic
element, symbols are composed of features, and rules are composed from symbols
and feature matrices.

@menu
* Features::
* Feature Matrices::
* Symbols::
* Rules::
* Imports::
* Comments::
* Strings::
@end menu

@node Features
@section Features

Features are the contrastive elements that compose the phonemes in your
phonology. Features must be declared before they can be used in symbols or
rules. 

@menu
* Basic Features::
* Unary Features::
* Binary Features::
* Scalar Features::
* Node Features::
@end menu

@node Basic Features
@subsection Basic Features

The simplest feature declaration looks like this:

@example

feature @var{feature-name}

@end example

The name of a feature can generally be anything, so long as it doesn't contain
spaces or characters with a special meaning in Phonix. For detailed rules, see
@ref{Strings}. For example:

@example

feature voice

@end example

The preceding example creates @code{voice} as a @dfn{binary feature}, meaning
that it may have the values @code{+voice} and @code{-voice}. (There is also a
third value @code{*voice} which will be talked about shortly.) Phonix supports
three types of features: @dfn{unary}, @dfn{binary}, and @dfn{scalar}. By
default all features are binary. To declare a feature of a different type, you
must use the extended syntax:

@example

feature @var{feature-name} (@var{parameter-name}=@var{parameter-value})

@end example

Note that the parenthesis around the parameter list is part of the syntax and
cannot be omitted. Currently the only parameters allowed on feature
declarations are @code{type}, which may have the values @code{unary},
@code{binary}, @code{scalar}, or @code{node}, and @code{children}, which is
discussed under @ref{Node Features}.

These feature types are discussed in detail in the following sections.

@node Unary Features
@subsection Unary Features

The following example declares a unary feature @samp{un}:

@example

feature un (type=unary)

@end example

Unary features are either @dfn{present} or @dfn{absent}. A unary feature which
is present is written with the feature name and no other decoration: @code{un}.
A unary feature which is absent is preceded by @samp{*}: @code{*un}.

Unary features are also called "privative features" in linguistic literature.

@node Binary Features
@subsection Binary Features

The following example declares a binary feature @samp{bn}:

@example

feature bn (type=binary)

@end example

Binary features have both @dfn{positive} and @dfn{negative} values, written as
@code{+bn} and @code{-bn} respectively. Additionally, a binary feature may be
@dfn{absent}, which is written the same way as for unary features: @code{*bn}.
For example, the features @samp{anterior} and @samp{distributed} are not
meaningful except as applied to coronals, so a labial segment would have the
value @code{*anterior}. 

@node Scalar Features
@subsection Scalar Features

The following example declares a scalar feature:

@example
feature sc (type=scalar)
@end example

Scalar features may have any non-negative integer value, and are written as
@code{sc=@var{value}}. For example, @code{sc=0}, @code{sc=1}, and
@code{sc=123456789} are all valid scalar feature values. However, @code{sc=-1}
and @code{sc=foo} are not valid. Scalar features may also be absent, in which
case they are written @code{*sc}.

@node Node Features
@subsection Node Features

Node features are used to represent @emph{feature trees}, as used in many
phonologcal theories. All of the other feature types are single features with
their own values. A node feature, on the other hand, represents a collection of
child features, and the value of a node feature is the value of all of its
children.

A node feature is declared with the parameter @code{type=node} and the
@code{children} parameter. For example:

@example
feature nd (type=node children=a,b.c)
@end example

The @code{children} parameter is required for node features, and forbidden on
all other feature types. Its value is a list of the child features, separated
by commas. You cannot put spaces after the commas unless you put the whole list
in quotes, e.g. @code{children=a,b,c} or @code{children="a, b, c"}. The
features that you declare as children must have been declared before you
declare the node feature.

Feature nodes can have any kind of feature as a child, including other nodes.
This allows you to create a multi-level hierarchies. For an example of such a
feature tree, see @ref{std.features}.

Feature nodes are @dfn{present} if any of their child features are present
(i.e. if any child feature has a value other than @code{*feature}), otherwise
they are @dfn{absent}. Feature nodes are written the same way as unary
features, with @code{nd} for present and @code{*nd} for absent. Note that there
are some restrictions on where you can use node feature values.

@itemize

@item Node feature values can't be used at all in symbol declarations. Symbols
can only contain leaf features.

@item Present values can only be used in the @dfn{match} and @dfn{context}
portions of a rule. This is because it isn't meaningful to assign a "present"
value directly to a node.

@end itemize
@node Feature Matrices
@section Feature Matrices

A @dfn{feature matrix} is a set of features and their values, enclosed in
@samp{[]}. The following line represents a feature matrix.

@example
[+cons -son -cont -str -vc -ro]
@end example

Features that are present in your phonology but which are not listed in a
feature matrix are assumed to have the @dfn{absent} value. In the feature
matrix above, the vocalic feature @code{fr} (front) is unspecified, so it has
the default value of @code{[*fr]}.

Feature matrices are used to define symbols and rules. However, only unary,
binary, and scalar feature values can appear in symbols. Node feature values
and variable feature values cannot be used in symbol declarations.

@node Symbols
@section Symbols

A @dfn{symbol} in Phonix is a string of text that corresponds to a given
feature matrix. Symbols are used for three things:

@enumerate

@item To define the feature matrices represented by the strings in your lexicon
files.

@item To provide a convenient shortcut for writing rules that refer to specific
phonemes.

@item To define the strings used to represent feature matrices in output.

@end enumerate

A symbol declaration looks like this:

@example

symbol @var{symbol-string} @var{feature-matrix}

@end example

For example, this is the declaration of the symbol @samp{s} in the standard
symbol set:

@example

symbol s [+cons -son +cont +str -vc +ant -dist]

@end example

Any Unicode character that doesn't have a special meaning in Phonix can be used
in a symbol. So if you want to define ☃ (Unicode snowman) as a symbol in your
phonology, you go ahead and do that.

Symbols are not limited to single characters, either. The only caveat for
multi-character symbols is that Phonix always maps your input to the longest
matching symbol. For example, say you define the following symbols:

@example
symbol s  [...]
symbol k  [...]
symbol sk [...]
@end example

If your input or rules contain the characters @samp{sk}, these will be mapped
to the symbol /sk/, and not to the sequence /s/+/k/. To disambiguate such
strings in your rules, you can add spaces. The string @code{s k} appearing in a
rule will always be interpreted as /s/+/k/.

For many examples of symbol definitions, see @ref{std.symbols}.

@node Rules
@section Rules

The @dfn{rule} is the most complex and the most useful object in Phonix. A rule
describes the conditions under which one phonological unit is transformed into
another.

@menu
* Parts of a rule::
* Basic transformations::
* Inserting and deleting::
* Variable feature values::
* Node feature values::
* Assimilation and gemination::
* Rule parameters::
@end menu

@node Parts of a rule
@subsection Parts of a rule

A complete rule has the following syntax:

@example
rule @var{name} (@var{parameters}) @var{match} => @var{action} / @var{context} // @var{excluded-context}
@end example

@itemize

@item The @dfn{name} of the rule can be any Phonix string. @xref{Strings}.

@item The @dfn{parameters} are optional and define characteristics of how the
rule is applied. If you don't apply any parameters, you can omit the
parenthesis. Currently the supported parameters for rules are @code{filter} and
@code{direction}. @xref{Rule parameters}.

@item The @dfn{match} is a sequence of feature matrices or symbols that matches
the segments that the transformation works on.

@item The @dfn{action} is sequence of feature matrices or symbols that defines
the transformations applied to the match.

@item The @dfn{context} defines the conditions under which the transformation
occurs. These are the adjacent segments which aren't themselves altered, but
which are required to trigger the rule. If the rule is @dfn{unconditional} and
does not depend on the surrounding segments, you can omit the context and the
excluded context.

@item The @dfn{excluded-context} defines conditions under which the rule should
not apply. Thus, this indicates exceptions to the conditions in the context.

@end itemize

These are described in more detail in the following sections.

@node Basic transformations
@subsection Basic transformations

The simplest transformation is one that has no context or parameters and acts
only on a single phoneme, as in the following example.

@example
rule s-to-z s => z
@end example

The @dfn{match} here is the segment /s/, and the @dfn{action} is to turn all
such segments into /z/. Since /s/ and /z/ differ only by voice, we can also
write this rule like this (using the appreviation @code{vc} for voice, as in
the standard feature set):

@example
rule s-voicing s => [+vc]
@end example

Here the action is a feature matrix rather than a segment. The effect of this
is to take whichever value for @code{voice} the input previously had and
replace it with @code{+voice}. You can use a feature matrix in the match to
match against a class of segments:

@example
rule continuant-voicing [+cont] => [+vc]
@end example

This matches all segments that have the feature @code{+cont} and applies the
feature @code{+vc} to them.

Most rules do not apply everywhere, however, but have some @dfn{context}. The
context consists of, at minimum, the character @code{_} with any number of
feature matrices or symbols before or after it. The @code{_} character stands
for the segment(s) of the match/action. Regardless of how many segments are
matched or transformed, you must write only one underscore. For example, let's
modify our previous rule to only apply after a nasal:

@example
rule postnasal-voicing [+cont] => [+vc] / [+nas] _
@end example

In this case, the context @code{/ [+nas] _} indicates that the segments matched
must be preceded by a segment with the feature @code{+nas}.

To indicate word boundaries we use @code{$}. The @code{$} character can stand
for either the beginning or the end of a word. It can only appear as the first
or the last character of the rule context (or both), but it cannot appear
internal to a rule. Suppose that we wish to further restrict our rule to only
apply at the end of a word. In this case, we write this:

@example
rule final-postnasal-voicing
[+cont] => [+vc] / [+nas] _ $
@end example

(Note that we've broken this rule into two lines. This is perfectly acceptable:
Phonix is usually indifferent to the spaces and line breaks in your phonology
file.)

If we wish to add an exception to this rule, we use the @emph{excluded
context}. This is indicated by a double-slash @code{//} after the context. If
the rule includes an excluded context, then phonix will check both that the
context matches the input and that the excluded context does @emph{not} match.
For example:

@example
rule postnasal-voicing-with-exception
[+cont] => [+vc] / [+nas] _ // N _
@end example

Here we voice continuants after nasals, @emph{except} after /N/ (the velar
nasal).

If you wish, you can also indicate the excluded context without the context:

@example
rule voicing-with-exception
[+cont] => [+vc] // $ _
@end example

This voices all continuants unless they are the first segment in the word. Note
that we could accomplish the exact same thing with:

@example
rule voicing-with-exception
[+cont] => [+vc] / [] _
@end example

Here, we specify that voicing occurs when the continuant is preceded by any
segment. (A feature matrix with no values @code{[]} effectively acts as a match
for any segment.) This illustrates that an excluded context can usually be
indicated by a properly constructed matching context and vice-versa. The
excluded context construct is provided only to make rules clearer and easier to
understand.

@node Inserting and deleting
@subsection Inserting and deleting

Insertion and deletion rules are written with the help of the special character
@code{*}, which you should think of as "nothing". To write an insertion rule,
specify that "nothing" becomes something:

@example
rule e-epenthesis
* => e / $ _ s[-cont]
@end example

This is the familiar rule found in many Romance languages which adds an
epenthetic /e/ following an initial cluster with /s/.

The opposite of insertion is deletion, in which something becomes nothing.
E.g.:

@example
rule final-cons-deletion
[-son] => * / _ $
@end example

Here, the "something" is any non-sonorant (@code{-son}), which becomes nothing
when followed by the word boundary.

Our nothing character is important when writing coalescence rules, in which
multiple segments become one. For example, to express that /s/+/k/ becomes /S/,
you @emph{cannot} write the following:

@example
# DOES NOT WORK - Phonix will not compile this line
rule sk-coalescence sk => S
@end example

The problem with this is that you must have the same number of segments both
before and after the @code{=>} symbol. To accomplish what you want, just add a
little nothing to balance out the rule:

@example
rule sk-coalescence sk => S*
@end example

This rule will compile and function as expected.

@node Variable feature values
@subsection Variable feature values

It is common for linguistic rules to require that features on related segments
be the same without specifying what the particular value is. The linguistic
literature traditionally indicates such values with Greek letters to represent
the variables. Phonix allows you to indicate such rules without the Greek using
@dfn{variable feature values}, which are indicated by @code{$}. In general, a
variable feature value indicated by @code{$@var{feature-name}} means that
@var{feature-name} must have the same value everywhere it appears.

Consider the following rule:

@example
rule cluster-spirantization [$vc -son] => [+cont] / _ [$vc -son]
@end example

This rule in English reads as "spirantize any non-sonorant when followed by
another non-sonorant of the same voicing". The feature values @code{-son} and
@code{+cont} are ordinary feature values and indicate that both the matched
segment and the following context segment must be non-sonorants, and that the
matched segment becomes a continuant. The feature value @code{$vc} is
different: it doesn't stipulate @code{+vc} or @code{-vc}, but rather requires
that the value for @code{vc} be the same in both the match and context
segments. 

This extends to rule actions, which is perhaps a more common case. The
following illustrates a nasal assimilation rule:

@example
rule nasal-assimilate [-cont] => [$nas $son] / _ [-cont $nas $son]
@end example

This rule reads as "any non-continuant takes the nasality and sonority of a
following non-contiuant segment". This will cause, for example /d/+/m/ to
become /n/+/m/, while /n/+/b/ becomes /d/+/b/. The values @code{$nas $son} in
the rule action have the effect of setting @code{nas} and @code{son} in the
matched segment to whatever value they have in the context segment.

In order for a variable feature value to be meaningful, it has to occur at
least twice in a rule. Consider the following modified example:

@example
rule nasal-assimilate-mod [-cont] => [$nas] / _ [-cont $nas $son]
@end example

This rule parses and executes without any warning, but the value @code{$son}
has no effect, because it has to occur in at least two places in order to match
or transform anything.

The following example, however, will generate a warning whenever the rule
applies:

@example
rule nasal-assimilate-mod [-cont] => [$nas $son] / _ [-cont $nas]
@end example

In this case we are trying to set the value of @code{son} in the rule action,
but the value the value for @code{son} is not defined anywhere else in the
rule. Since this usually indicates a mistake, Phonix issues a warning and leave
the value of @code{son} unchanged.

@node Node feature values
@subsection Node feature values

Node features are features with one or more child features (@pxref{Node
Features}), and they have some special properties.

A node feature is @dfn{present} if one or more of its children is present. Node
features don't have any value of their own. Within a rule you can use the same
syntax that is used for unary values to test for the presence of a node:

@example
rule postlabial-centralization
[+fr -bk] => [-fr] / [Labial] _
@end example

In this case we are testing for the presence of the @code{Labial} node. This is
especially convenient because it allows us to capture both @code{+ro} segments
(rounded vowels) and @code{-ro} segments (labial consonants), which otherwise
can't be represented in a natural class.

Conversely, you can test for the absence of a particular node by testing for
@code{*Labial}. The following rule centralizes vowels after non-@code{Coronal}
segments.

@example
rule nonlabial-centralization
[+fr -bk] => [-fr] / [*Coronal] _
@end example

Within the action portion of a rule, you can use this syntax to set an entire
group of segments to their absent values. For example, the following rule
reduces all stops in final position to /?/ by removing all of their segments
under the @code{Place} node.

@example
rule final-glottalization
[-cont] => [*Place] / _ $
@end example

As this rule illustrates, you may use the @code{*Node} syntax in a rule action,
but you cannot use the @code{Node} syntax in an action, because it makes no
sense to assign a value directly to a node. A node is present if one of its
children is present, so in order to make a node be present, assign a value to
one of its children.

@node Assimilation and gemination
@subsection Assimilation and gemination

Node features (@pxref{Node Features}) are especially useful for assimilation and
gemination rules. One of the most common phonological processes
cross-linguistically is @emph{nasal place assimilation}, by which nasals in
coda positions take on the place of the following segments. These rules can be
written with a flat feature set by using several different variable values, for
every feature that represents a part of the notion of "place". However, this
can get very cumbersome--consider that to write a @emph{total} assimilation
rule, you would need to mention write every single feature in your phonology as
a variable in your rule.

However, these processes are considerably simplified by using node features.
For example, using @ref{std.features}, we can write a nasal place assimilation
rule as follows:

@example
rule nasal-place-assimilation
[+nas] => [$Place] / _ [+cons $Place]
@end example

This rule is greatly simplified by using the @code{Place} node, which has as
its children all of the features that contribute to place of articulation. You
can extend this even further for a gemination rule that duplicates @emph{all}
of the features for a given segment:

@example
rule intervocalic-gemination
* => [$ROOT] / [-cons][+cons $ROOT] _ [-cons]
@end example

Here a consonantal segment is doubled when surrounded on either side by
non-consonantal segments. The feature @code{ROOT} has as its children every
feature in @code{std.features}, and so the inserted segment copies every value
from the preceding segment.

@node Rule parameters
@subsection Rule parameters

Rule parameters alter the execution of your rule in some way that can't be
indicated in the rule itself. Parameters take the form
@code{@var{param-name}=@var{param-value}}, and are enclosed in parentheses
after the rule name, with spaces between them if there are more than one. The
following rule example specifies the @code{direction} and @code{filter}
parameters:

@example
rule leftward-example (direction=right-to-left filter=[+cons]) s => z
@end example

Supported rule parameters are discussed below.

@menu
* Direction::
* Filter::
@end menu

@node Direction
@subsubsection Direction

The rule direction defines in which direction the rule scans for matching
contexts. This can be important if one application of a rule may create the
context for further applications. To specify the direction for a rule, specify
the parameter @code{direction=@var{direction-value}}. Valid direction values
are @code{left-to-right} and @code{right-to-left}, with @code{left-to-right} as
the default.

A good example for a direction-sensitive rule is voice agreement. Suppose we
have a rule that all consonants in a cluster must agree with the voice of the
last consonant. The following rule does not accomplish that:

@example
# This doesn't work as expected
rule voicing-agreement 
[+cons] => [+vc] / _ [+cons +vc]
@end example

Given an input word like @code{astga}, the output of this rule will be
@code{asdga}---only the second consonant in the cluster is affected. This is
because the default rule direction is to the right. First the /s/ is evaluated,
but this /s/ is followed by /t/, so the rule does not apply. Then the /t/
followed by /g/ is evaluated. This does match the required context, so /t/
becomes /d/. However, the /s/ is never reevaluated. To fix this, specify that
the rule applies from the right to the left:

@example
rule voicing-agreement (direction=right-to-left)
[+cons] => [+vc] / _ [+cons +vc]
@end example

This rule will transform @code{astga} into @code{azdga}. First /t/ followed by
/g/ is evaluated, transforming the /t/ into /d/, then /s/ followed by /d/ is
evaluated, giving /z/.

@node Filter
@subsubsection Filter

Rule filters are a powerful way to express rules that only apply to certain
classes of segments and ignore intervening segments. The most familiar
real-world example of this is vowel harmony, which typically works on vowels
regardless of intervening consonants. To add a filter to a rule, specify the
parameter @code{filter=@var{filter-value}}, where the filter value may be a feature
matrix or a symbol.

When you apply a filter, the rule acts as if those segments not matching the
filter were not present at all in the input. Take the following vowel harmony
rule:

@example
rule vowel-harmony (filter=[+syll])
[-fr] => [+fr -bk] / _ [+fr]
@end example

This rule turns back vowels into front vowels when followed by other front
vowels, and will work correctly regardless of how many non-vowel segments
intervene between the vowels. The filter @code{[+syll]} effectively removes all
non-syllabic constants from the input for the duration of the rule. Therefore,
the context of the rule is written as if the front vowel that triggers vowel
harmony immediately follows the matching vowel.

@node Imports
@section Imports

You can include Phonix files from other Phonix files using the @code{import}
command. There are also several built-in resources that you can use, which are
covered in this section.

@menu
* Importing files::
* std.features::
* std.symbols::
* std.symbols.ipa::
@end menu

@node Importing files
@subsection Importing files 

@example
import @var{filename}
@end example

The @dfn{filename} given to the import command follows the same rules as other
Phonix strings, which means that you need to quote it if it contains certain
characters that have special meaning for Phonix. For details, @xref{Strings}.
Examples:

@example
import other-phonology.phonix
import "/home/linguist/latin.phonix"
import "C:\greek.phonix"
@end example

If the file name that you give after @code{import} is not an absolute path
(however that is defined on your local system), Phonix looks for the file you
imported in the following places:

@enumerate

@item In the current directory.

@item In the same directory as the Phonix file currently being parsed (if that
directory is different from the current directory).

@item In a named resource.

@end enumerate

The @dfn{named resources} that Phonix looks for are special "filenames" that
represent built-in feature or symbol sets meant to simplify common linguistic
tasks. The following sections describe these resources.

@node std.features
@subsection std.features

The standard feature set contains the commonly used features that you probably
learned about in your introductory Phonology class. You include the standard
feature set by writing @code{import std.features}. All of the features in the
standard set are binary features given in their abbreviated forms. The features
are gathered into a feature tree following this naming convention: leaf
features are written in lower case, node features are written in initial caps,
and the @code{ROOT} feature is written in all caps. The tree has the following
structure:

@example
+ROOT
    +Place
        +Labial
            -ro
        +Coronal
            -ant
            -dist
        +Dorsal
            -hi
            -lo
            -bk
            -fr
    +Glottal
        -vc
        -sg
        -cg
    +Manner
        -cont
        -nas
        -str
        -lat
        -dr
        +Class
            -cons
            -syll
            -son
@end example

The @code{std.features} file itself looks like this:

@example
@verbatiminclude Resx/std.features
@end example

@node std.symbols
@subsection std.symbols

The standard symbol set contains over 100 phonetic symbols that you can use for
input and output. In order to use the standard symbol set, you have to first
import the standard feature set @code{std.features}, since the standard symbols
depend on the features defined in that set. You include the standard symbols by
writing @code{import std.symbols}. The standard symbol set uses only 7-bit
ASCII characters and is based on the X-SAMPA IPA encoding.

@example
@verbatiminclude Resx/std.symbols
@end example

@node std.symbols.ipa
@subsection std.symbols.ipa

The IPA symbol set contains the same notional symbols as @code{std.symbols},
but it uses IPA Unicode characters instead of ASCII X-SAMPA. To use the IPA
symbol set, write @code{import std.features} and @code{import std.symbols.ipa}
at the top of your file.

@iftex
Unfortunately, not all IPA symbols used in this set are present in the fonts
used in this PDF, so some of these symbols may appear to have blank symbols.
@end iftex

@example
@verbatiminclude Resx/std.symbols.ipa
@end example

@node Comments
@section Comments

In Phonix the comment character is @code{#}. Everything from @code{#} to the
end of a line is a comment and is silently ignored by Phonix (unless the
@code{#} character is embedded in a string). For example:

@example
# This is a comment
feature ex # this comment explains what 'ex' means
@end example

@node Strings
@section Strings

Any time that Phonix expects you to provide a string, as for feature names,
symbols, or a rule names, you can type almost anything you want.  The only
exception is if the contents of the string somehow confuse the Phonix compiler.
Don't do that. Everything else is fine.

The long, boring, technical version follows.

Phonix recognizes two types of strings: @dfn{bare} strings and @dfn{quoted}
strings. Most of the time you can use bare strings, which keeps your Phonix
file nice and uncluttered. The rules for bare strings are extremely forgiving,
to minimize the situation where you have to use a quoted string:

@itemize

@item A bare string cannot contain whitespace. More specifically, whitespace is
always interpreted as a token delimiter outside of a quoted string, which
implicitly means it cannot be part of a string.

@item A bare string cannot contain any of the characters @code{[]()$=} @emph{at
all}. 

@item A bare string cannot begin with any of the characters @code{+-*/#_"'}.
However, these characters can appear in the middle of strings.

@end itemize

This should be enough for almost all cases, but in case it's not, you can also
create a quoted string by surrounding a string with single quotes (@code{'}) or
double quotes (@code{"}). If you are using a quoted string in a rule or a
symbol declaration, the opening quote must be preceded by a space. Anything at
all can appear inside a quoted string, except for another quote, of course.
There is no mechanism for escaping quotes, so if you need to include a single
quote then surround your quote with double quotes, and vice versa.

@node Examples
@chapter Examples

The following examples illustrate common use cases for Phonix.

@menu
* Romanian::
@end menu

@node Romanian
@section Romanian

The following example files define a phonology for contemporary Romanian, and
illustrates how most of the surface alternations in Romanian can be derived.
Note that the example is somewhat incomplete: the input represents an internal
reconstruction of Proto-Romanian, not Proto-Romance or Vulgar Latin, and there
may be a few alternations that slipped by me. However, the majority of the
active phonological processes in Romanian should be represented.

@subsection @file{romanian.phonix}

@example
@verbatiminclude examples/romanian.phonix
@end example

@subsection Input and output

You can generate the output file with the following command line:

@example
phonix romanian.phonix -i romanian.input -o romanian.output
@end example

The following table shows the input and the generated output together with the
output form in Romanian orthography.

@multitable @columnfractions .25 .25 .5
@headitem Input @tab Output @tab Orthography
@item @code{vedu} @tab @code{v@@'d} @tab văd
@item @code{vedi} @tab @code{ve'zj} @tab vezi
@item @code{vede} @tab @code{ve'de} @tab vede
@item @code{vedemu} @tab @code{vede'm} @tab vedem
@item @code{vedeti} @tab @code{vede'tsj} @tab vedeţi
@item @code{vedu} @tab @code{v@@'d} @tab văd
@item @code{veda} @tab @code{va'd@@} @tab vadă
@item @code{vezutu} @tab @code{v@@zu't} @tab văzut
@item @code{venu} @tab @code{vi'n} @tab vin
@item @code{veni} @tab @code{vi'j} @tab vii
@item @code{vene} @tab @code{vi'ne} @tab vine
@item @code{venimu} @tab @code{veni'm} @tab venim
@item @code{veniti} @tab @code{veni'tsj} @tab veniţi
@item @code{venu} @tab @code{vi'n} @tab vin
@item @code{vena} @tab @code{vi'n@@} @tab vină
@item @code{venitu} @tab @code{veni't} @tab venit 
@item @code{esu} @tab @code{je's} @tab ies
@item @code{esi} @tab @code{je'Sj} @tab ieşi
@item @code{ese} @tab @code{je'se} @tab iese
@item @code{esimu} @tab @code{jeSi'm} @tab ieşim
@item @code{esiti} @tab @code{jeSi'tsj} @tab ieşiţi
@item @code{esu} @tab @code{je's} @tab ies
@item @code{esa} @tab @code{ja's@@} @tab iasă
@item @code{esitu} @tab @code{jeSi't} @tab ieşit
@item @code{potu} @tab @code{po't} @tab pot
@item @code{poti} @tab @code{po'tsj} @tab poţi
@item @code{pote} @tab @code{po`a'te} @tab poate
@item @code{potemu} @tab @code{pute'm} @tab putem
@item @code{poteti} @tab @code{pute'tsj} @tab puteţi
@item @code{potu} @tab @code{po't} @tab pot
@item @code{pota} @tab @code{po`a't@@} @tab poată
@item @code{potutu} @tab @code{putu't} @tab putut 
@item @code{keru} @tab @code{tSe'r} @tab cer
@item @code{keri} @tab @code{tSe'rj} @tab ceri
@item @code{kere} @tab @code{tSe're} @tab cere
@item @code{ke'remu} @tab @code{tSe'rem} @tab cerem
@item @code{ke'reti} @tab @code{tSe'retsj} @tab cereţi
@item @code{keru} @tab @code{tSe'r} @tab cer
@item @code{kera} @tab @code{tSa'r@@} @tab ceară
@item @code{kerutu} @tab @code{tSeru't} @tab cerut
@item @code{portu} @tab @code{po'rt} @tab port
@item @code{porti} @tab @code{po'rtsj} @tab porţi
@item @code{porta} @tab @code{po`a'rt@@} @tab poartă
@item @code{portamu} @tab @code{purt@@'m} @tab purtăm
@item @code{portati} @tab @code{purta'tsj} @tab purtaţi
@item @code{porta} @tab @code{po`a'rt@@} @tab poartă
@item @code{porte} @tab @code{po`a'rte} @tab poarte
@item @code{portatu} @tab @code{purta't} @tab purtat
@item @code{freku} @tab @code{fre'k} @tab frec
@item @code{freki} @tab @code{fre'tS} @tab freci
@item @code{freka} @tab @code{fre`a'k@@} @tab freacă
@item @code{frekamu} @tab @code{frek@@'m} @tab frecăm
@item @code{frekati} @tab @code{freka'tsj} @tab frecaţi
@item @code{freka} @tab @code{fre`a'k@@} @tab freacă
@item @code{freke} @tab @code{fre'tSe} @tab frece
@item @code{klemu} @tab @code{kje'm} @tab chem
@item @code{klemi} @tab @code{kje'mj} @tab chemi
@item @code{klema} @tab @code{kja'm@@} @tab cheamă
@item @code{klemamu} @tab @code{kjem@@'m} @tab chemăm
@item @code{klemati} @tab @code{kjema'tsj} @tab chemaţi
@item @code{klema} @tab @code{kja'm@@} @tab cheamă
@item @code{kleme} @tab @code{kja'm@@} @tab cheamă *Note that this is the regular outcome of the sound change, but this form (the 3rd person subjunctive) has been analogically restored to 'cheme' in the standard language.
@item @code{kalu} @tab @code{ka'l} @tab cal
@item @code{kali} @tab @code{ka'j} @tab cai
@item @code{udu} @tab @code{u'd} @tab ud
@item @code{uda} @tab @code{u'd@@} @tab udă
@item @code{ude} @tab @code{u'de} @tab ude
@item @code{udi} @tab @code{u'zj} @tab uzi
@item @code{pro'spetu} @tab @code{pro`a'sp@@t} @tab proaspăt
@item @code{pro'speta} @tab @code{pro`a'sp@@t@@} @tab proaspătă
@item @code{pro'speti} @tab @code{pro`a'spetsj} @tab proaspeţi
@item @code{pro'spete} @tab @code{pro`a'spete} @tab proaspete
@item @code{osu} @tab @code{o's} @tab os
@item @code{ose} @tab @code{o`a'se} @tab oase
@item @code{oie} @tab @code{o`a'je} @tab oaie
@item @code{oi} @tab @code{oj} @tab oi
@item @code{ou} @tab @code{ow} @tab ou
@item @code{oue} @tab @code{o'w@@} @tab ouă
@item @code{peske} @tab @code{pe'Ste} @tab peşte
@item @code{peski} @tab @code{pe'Stj} @tab peşti
@item @code{oklu} @tab @code{o'kj} @tab ochi
@item @code{okli} @tab @code{o'kj} @tab ochi
@item @code{klaru} @tab @code{kja'r} @tab chiar
@end multitable

@node License
@appendix License

@include COPYRIGHT

@bye
